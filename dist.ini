name             = MarpaX-Languages-C-AST
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2013

; -- This is inspired from bundles Apocalyptic, Dagolden remarquable dist.ini

; -- Git stuff
[Git::NextVersion]              ; find the last tag, and bump to next version via Version::Next
version_regexp = ^v(.+)$        ; My tags has the format vd.dd
[Git::GatherDir]                ; Collect all files from git ls-files
exclude_filename = README.pod   ; skip this generated file
exclude_filename = META.json    ; skip this generated file
exclude_filename = Changes      ; skip this generated file
exclude_filename = dzil.sh      ; skip this file that runs all dzil stuff
[ContributorsFromGit]           ; Get contributors

[PruneCruft]                    ; automatically prune cruft defined by RJBS :)
[AutoPrereqs]                   ; automatically find our prereqs
skip = ^MarpaX::Languages::C::AST::Expected$ ; My personnal module that is in inc/
[ManifestSkip]                  ; skip files that matches MANIFEST.SKIP

; -- Generate extra tests
[@TestingMania]
disable = Test::UnusedVars      ; Not fatal IMHO and there are cases where this cannot be avoided
[RunExtraTests]                 ; run the xt/ tests when dzil test is run.

; -- munge files
[OurPkgVersion]                 ; Add $VERSION at "# VERSION"
[Authority]                     ; put the $AUTHORITY line in modules and the metadata
[PodWeaver]                     ; weave our POD and add useful boilerplate
[LocaleMsgfmt]                  ; compile .po files to .mo files in share/locale
locale = share/locale

; -- update the Changelog
[ChangelogFromGit::CPAN::Changes] ; Generated Changes from git
file_name = Changes
; -- generate/process meta-information
[ExecDir]                       ; automatically install files from bin/ directory as executables ( if it exists )
dir = bin
[ShareDir]                      ; automatically install File::ShareDir files from share/ ( if it exists )
dir = share
[MinimumPerl]                   ; automatically find the minimum perl version required and add it to prereqs
[AutoMetaResources] ; set META resources
bugtracker.rt      = 1
repository.github  = user:jddurand
homepage           = https://metacpan.org/release/%{dist}
[MetaProvides::Package] ; add 'provides' to META files
meta_noindex = 1        ; respect prior no_index directives
[MetaNoIndex]                   ; tell PAUSE to not index those directories
directory = inc
directory = t
directory = xt
directory = example
directory = examples
directory = share
directory = eg
directory = mylib
[License]                       ; create LICENSE file
[MakeMaker]                     ; create Makefile.PL file
[ModuleBuild]                   ; create Build.PL file
[DualBuilders]                  ; have M::B and EU::MM but select only EU::MM as prereq
prefer = build
[MetaYAML]                      ; create META.yml file
[MetaJSON]                      ; create META.json file
[ReadmeFromPod]                 ; create README file
[ReadmeAnyFromPod]              ; create README.pod in repo directory
type = pod
filename = README.pod
location = root
[InstallGuide]                  ; create INSTALL file
; [Signature]                     ; create SIGNATURE file when we are releasing ( annoying to enter password during test builds... )
; sign = archive
[Manifest]                      ; finally, create the MANIFEST file

; -- pre-release
[CheckChangesHasContent]        ; make sure you explained your changes :)
changelog = Changes
[Git::Check]                    ; check working path for any uncommitted stuff ( exempt Changes because it will be committed after release )
changelog = Changes
allow_dirty = Changes
allow_dirty = README.pod
allow_dirty = META.json
; [FakeRelease]                 ; Uncomment to fake a release
[TestRelease]                   ; make sure that we will not release a FAIL distro :)
[CheckPrereqsIndexed]           ; make sure that our prereqs actually exist on CPAN
[ConfirmRelease]                ; double-check that we ACTUALLY want a release, ha!

; -- release
[UploadToCPAN]                  ; upload your dist to CPAN using CPAN::Uploader

; -- post-release
[ArchiveRelease]                ; archive our tarballs under releases/
directory = releases
[Git::Commit]                   ; commit the dzil-generated stuff
changelog = Changes
commit_msg = New CPAN release of %N - v%v%n%n%c
time_zone = UTC
add_files_in = releases         ; add our release tarballs to the repo
[Git::Tag]                      ; tag our new release
tag_format = v%v
tag_message = Tagged v%v
[Git::Push]                     ; automatically push to the "origin" defined in .git/config
push_to = origin
[Clean]                         ; run dzil clean so we have no cruft :)
