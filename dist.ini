name             = MarpaX-Languages-C-AST
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2013

; -- This is inspired from bundles Apocalyptic, Dagolden remarquable dist.ini

; -- Git stuff
[Git::NextVersion]              ; find the last tag, and bump to next version via Version::Next
version_regexp = ^v(.+)$        ; My tags has the format vd.dd
[Git::GatherDir]                ; Collect all files from git ls-files
exclude_filename = README.pod   ; skip this generated file
exclude_filename = META.json    ; skip this generated file
exclude_filename = Changes      ; skip this generated file
exclude_filename = dzil.sh      ; skip this file that runs all dzil stuff
[ContributorsFromGit]           ; Get contributors

[PruneCruft]                    ; automatically prune cruft defined by RJBS :)
[AutoPrereqs]                   ; automatically find our prereqs
skip = ^MarpaX::Languages::C::AST::Expected$ ; My personnal module that is in inc/
[ManifestSkip]                  ; skip files that matches MANIFEST.SKIP

; -- Generate extra tests
[@TestingMania]
disable = Test::UnusedVars      ; Not fatal IMHO and there are cases where this cannot be avoided
[RunExtraTests]                 ; run the xt/ tests when dzil test is run.

; -- munge files
[OurPkgVersion]                 ; Add $VERSION at "# VERSION"
[Authority]                     ; put the $AUTHORITY line in modules and the metadata
[PodWeaver]                     ; weave our POD and add useful boilerplate
[LocaleMsgfmt]                  ; compile .po files to .mo files in share/locale
locale = share/locale

; -- update the Changelog
[ChangelogFromGit::CPAN::Changes] ; Generated Changes from git
file_name = Changes
; -- generate/process meta-information
[ExecDir]                       ; automatically install files from bin/ directory as executables ( if it exists )
dir = bin
[ShareDir]                      ; automatically install File::ShareDir files from share/ ( if it exists )
dir = share
[MinimumPerl]                   ; automatically find the minimum perl version required and add it to prereqs
[AutoMetaResources] ; set META resources
bugtracker.rt      = 1
repository.github  = user:jddurand
homepage           = https://metacpan.org/release/%{dist}
[MetaProvides::Package] ; add 'provides' to META files
meta_noindex = 1        ; respect prior no_index directives
[MetaNoIndex]                   ; tell PAUSE to not index those directories
directory = inc
directory = t
directory = xt
directory = example
directory = examples
directory = share
directory = eg
directory = mylib
[License]                       ; create LICENSE file
[MakeMaker]                     ; create Makefile.PL file
[ModuleBuild]                   ; create Build.PL file
[DualBuilders]                  ; have M::B and EU::MM but select only EU::MM as prereq
prefer = build
[MetaYAML]                      ; create META.yml file
[MetaJSON]                      ; create META.json file
[ReadmeFromPod]                 ; create README file
[ReadmeAnyFromPod]              ; create README.pod in repo directory
type = pod
filename = README.pod
location = root
[InstallGuide]                  ; create INSTALL file
; [Signature]                     ; create SIGNATURE file when we are releasing ( annoying to enter password during test builds... )
; sign = archive
[Manifest]                      ; finally, create the MANIFEST file

; -- pre-release
[Git::Check]                    ; check working path for any uncommitted stuff ( exempt Changes because it will be committed after release )
changelog = Changes
allow_dirty = Changes
allow_dirty = README.pod
allow_dirty = META.json

[CheckMetaResources]     ; ensure META has 'resources' data
[CheckPrereqsIndexed]    ; ensure prereqs are on CPAN
[CheckChangesHasContent] ; ensure Changes has been updated
[CheckExtraTests]   ; ensure xt/ tests pass
[TestRelease]       ; ensure t/ tests pass
[ConfirmRelease]    ; prompt before uploading
 
; releaser
[UploadToCPAN]      ; uploads to CPAN
 
; after release
[Git::Commit / Commit_Dirty_Files] ; commit Changes (as released)
 
[Git::Tag]          ; tag repo with custom tag
tag_format = v%v
 
; NextRelease acts *during* pre-release to write $VERSION and
; timestamp to Changes and  *after* release to add a new {{$NEXT}}
; section, so to act at the right time after release, it must actually
; come after Commit_Dirty_Files but before Commit_Changes in the
; dist.ini.  It will still act during pre-release as usual
 
[NextRelease]
 
[Git::Commit / Commit_Changes] ; commit Changes (for new dev)
changelog = Changes
commit_msg = New CPAN release of %N - v%v%n%n%c
time_zone = UTC

[Git::Push]         ; push repo to remote
push_to = origin
[Clean]                         ; run dzil clean so we have no cruft :)
